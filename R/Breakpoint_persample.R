#' Tag breakpoint position in each transcript of partner genes
#'
#' @description Tag breakpoint position in each transcript (e.g. at exon boundary/within exon or within intron, exon rank) of partner gene
#'              for two-way plotting in per_sample tab-panel
#'
#' @param breakpoint A numeric vector (containing only one element) represents genomic coordinate of geneA / geneB breakpoint.
#' @param object A list collects geneA / geneB breakpoint annotation, two keys elements (i.e. a GRange object: \code{object\$txTr_f}, a data.frame object: \code{object\$dataset}).
#' @param whole_tx A GRange object - exon intervals grouped by transcript per gene, which is generated by processing \code{txdb_ref} object.
#' @param offset A numeric value - extend the partner gene region (default: 2000, e.g. [start-offset, end+offset]).
#'
#' @return A list with two data.frame elements (i.e. \code{transcript} and \code{select_region}) with transcript and breakpoint annotations of partner genes
#'
#' @export
gene_trans_ex <- function(breakpoint, object, whole_tx, offset=2000) {
	# For testing: breakpoint = breakpoint_set[1,1]; object; whole_tx = whole_txdb
	dataset = object$dataset
	start = object$start
	end = object$end
	strand = object$strand
	chr = object$chr
	txTr_f = object$txTr_f

	#// if breakpoint outside of gene, return NULL
	if ( breakpoint < start-offset || breakpoint > end+offset ) { return(NULL) }

	select_region_f = NULL; #// a data.frame class to collect annotations and structures (5utr-cds-utr3) of transcripts for geneA or geneB
	JE = NULL; #// a data.frame to collect breakpoint judgement (1, 2, 3 or 4), exon_number, transcript_length and exon_id harboring breakpoint or close to breakpoint
	for ( x in 1:length(dataset[,1])) { #// not important whether x is either character or numeric
		name = dataset[x,]$TXNAME #// transcript_id e.g. name = "ENST00000398585"
		trans_start = dataset[x,]$TXSTART #// transcript start used for calculating the relative position of breakpoint to it (out of transcript region)
		trans_end = dataset[x,]$TXEND #// transcript end used for calculating the relative position of breakpoint to it (out of transcript region)

		#// assign exon names if they are missing in GRange object (shown as "5-utr-cds-utr-3 structure" in txTr_f)
		if ( strand == "+" ) {
			all_exon_tx_A = whole_tx[[name]]
		} else { #// if negative strand, reverse exon order
			all_exon_tx_A = rev(whole_tx[[name]])
		}
		ref_point = GenomicRanges::findOverlaps(txTr_f[Gviz::transcript(txTr_f)==name]@range, all_exon_tx_A) #// run GRange overlapping
		#// assign exon name
		txTr_f@range@elementMetadata[txTr_f@range@elementMetadata$transcript==name,]$exon[S4Vectors::queryHits(ref_point)] = all_exon_tx_A$exon_name[S4Vectors::subjectHits(ref_point)]
		region_f = as.data.frame(txTr_f[Gviz::transcript(txTr_f)==name]@range) #// convert GeneRegionTrack(Rle) to data.frame structure

		#// get exon (utr+cds) structure
		region_f_group = as.data.frame(all_exon_tx_A); #// convert GeneRegionTrack(Rle) to data.frame structure (exon as unit)
		colnames(region_f_group)[7] = "exon"
		colnames(region_f_group)[8] = "EXONRANK"
		region_f_group = region_f_group[order(region_f_group$start), , drop=F] #// rank by start pos
		if ( strand == "+" ) {
			region_f_group$EXONRANK = c(1:length(region_f_group[,1]));
		} else {
			region_f_group$EXONRANK = c(length(region_f_group[,1]):1);
		}

		flag = NULL #// a tag used for marking the exon in which breakpoint falls or is closed
		Judge = 0; Exon_num = 0; #// Judge=1 (at exon boundary), 2 (within exon), 3 (within intron), 4 (outside of transcript)

		if ( length(region_f_group[,1]) == 1 ) { #// if the transcript has only one exon
			if ( breakpoint >= region_f_group[1,]$start && region_f_group[1,]$end >= breakpoint ) { #// breakpoint at exon boundary or within exon
				if ( as.character(region_f_group[1,]$strand) == "+" ) {
					prop = (breakpoint - region_f_group[1,]$start + 1)/(region_f_group[1,]$end - region_f_group[1,]$start + 1); #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				} else if ( as.character(region_f_group[1,]$strand) == "-" ) {
					prop = (region_f_group[1,]$end - breakpoint + 1)/(region_f_group[1,]$end - region_f_group[1,]$start + 1); #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				}
				if ( breakpoint == region_f_group[1,]$start || region_f_group[1,]$end == breakpoint ) { #// breakpoint at exon boundary
					Judge = 1; Exon_num = region_f_group[1,]$EXONRANK
				} else { #// breakpoint within exon
					Judge = 2; Exon_num = region_f_group[1,]$EXONRANK
				}
			} else if ( breakpoint < region_f_group[1,]$start ) { #// breakpoint < start_exon of transcript
				if ( as.character(region_f_group[1,]$strand) == "+" ) {
					prop = (trans_start - breakpoint + 1)/(trans_end - breakpoint + 1) #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				} else if ( as.character(region_f_group[1,]$strand) == "-" ) {
					prop = (trans_start - breakpoint + 1)/(trans_end - breakpoint + 1) #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				}
				Judge = 4; Exon_num = paste(0, '_', region_f_group[1,]$EXONRANK, sep="")
			} else { #// breakpoint > end_exon of transcript
				if ( as.character(region_f_group[1,]$strand) == "+" ) {
					prop = (breakpoint - trans_end + 1)/(breakpoint - trans_start + 1) #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				} else if ( as.character(region_f_group[1,]$strand) == "-" ) {
					prop = (breakpoint - trans_end + 1)/(breakpoint - trans_start + 1) #// 0 <= prop <= 1
					flag = region_f_group[1,]; flag[,"Prop"] = prop;
				}
				Judge = 4; Exon_num = paste(region_f_group[1,]$EXONRANK, '_', 0, sep="")
			}
		} else { #// the transcript has more than one exon
			y = length(region_f_group[,1]) - 1
			for (z in 1:y) {
				if ( z==1 ) { #// if loop at the first exon
					if ( breakpoint < region_f_group[z,]$start ) { #// breakpoint < start_exon_first of transcript
						if ( as.character(region_f_group[z,]$strand) == "+" ) {
							prop = (trans_start - breakpoint + 1)/(trans_end - breakpoint + 1) #// 0 <= prop <= 1
							flag = region_f_group[z,]; flag[,"Prop"] = prop
						} else if ( as.character(region_f_group[z,]$strand) == "-" ) {
							prop = (trans_start - breakpoint + 1)/(trans_end - breakpoint + 1) #// 0 <= prop <= 1
							flag = region_f_group[z,]; flag[,"Prop"] = prop
						}
						Judge = 4; Exon_num = paste(0, '_', region_f_group[z,]$EXONRANK, sep="")
						break
					}
				}
				if ( breakpoint >= region_f_group[z,]$start && breakpoint <= region_f_group[z,]$end ) { #// breakpoint at exon boundary or within exon
					if ( as.character(region_f_group[z,]$strand) == "+" ) {
						prop = (breakpoint - region_f_group[z,]$start + 1)/(region_f_group[z,]$end - region_f_group[z,]$start + 1); #// 0 <= prop <= 1
						flag = region_f_group[z,]; flag[,"Prop"] = prop
					} else if ( as.character(region_f_group[z,]$strand) == "-" ) {
						prop = (region_f_group[z,]$end - breakpoint + 1)/(region_f_group[z,]$end - region_f_group[z,]$start + 1); #// 0 <= prop <= 1
						flag = region_f_group[z,]; flag[,"Prop"] = prop
					}
					if ( breakpoint == region_f_group[z,]$start || region_f_group[z,]$end == breakpoint ) { #// breakpoint at exon boundary
						Judge = 1; Exon_num = region_f_group[z,]$EXONRANK
					} else { #// breakpoint within exon
						Judge = 2; Exon_num = region_f_group[z,]$EXONRANK
					}
					break
				} else if ( breakpoint > region_f_group[z,]$end && region_f_group[z+1,]$start > breakpoint ) { #// breakpoint within intron
					if ( as.character(region_f_group[z,]$strand) == "+" ) {
						prop = (breakpoint - region_f_group[z,]$end + 1)/(region_f_group[z+1,]$start - region_f_group[z,]$end + 1); #// 0 <= prop <= 1
						flag = region_f_group[z,]; flag[,"Prop"] = prop
					} else if ( as.character(region_f_group[z,]$strand) == "-" ) {
						prop = (region_f_group[z+1,]$start - breakpoint + 1)/(region_f_group[z+1,]$start - region_f_group[z,]$end+ 1); #// 0 <= prop <= 1
						flag = region_f_group[z+1,]; flag[,"Prop"] = prop
					}
					Judge = 3; Exon_num = paste(region_f_group[z,]$EXONRANK, '-', region_f_group[z+1,]$EXONRANK, sep="")
					break
				}
				if ( z == y ) { #// loop at the second last exon
					if ( breakpoint >= region_f_group[z+1,]$start && region_f_group[z+1,]$end >= breakpoint ) { #// breakpoint at the boundary or within the last exon
						if ( as.character(region_f_group[z+1,]$strand) == "+" ) {
							prop = (breakpoint - region_f_group[z+1,]$start + 1)/(region_f_group[z+1,]$end - region_f_group[z+1,]$start + 1); #// 0 <= prop <= 1
							flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						} else if ( as.character(region_f_group[z+1,]$strand) == "-" ) {
							prop = (region_f_group[z+1,]$end - breakpoint + 1)/(region_f_group[z+1,]$end - region_f_group[z+1,]$start + 1); #// 0 <= prop <= 1
							flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						}
						if ( breakpoint == region_f_group[z+1,]$start || region_f_group[z+1,]$end == breakpoint ) { #// breakpoint at the boundary of the last exon
							Judge = 1; Exon_num = region_f_group[z+1,]$EXONRANK
						} else { #// breakpoint within the last exon
							Judge = 2; Exon_num = region_f_group[z+1,]$EXONRANK
						}
						break
					} else { #// breakpoint > end of last exon
						if ( as.character(region_f_group[z+1,]$strand) == "+" ) {
							prop = (breakpoint - trans_end + 1)/(breakpoint - trans_start + 1) #// 0 <= prop <= 1
							flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						} else if ( as.character(region_f_group[z+1,]$strand) == "-" ) {
							prop = (breakpoint - trans_end + 1)/(breakpoint - trans_start + 1) #// 0 <= prop <= 1
							flag = region_f_group[z+1,]; flag[,"Prop"] = prop
						}
						Judge = 4; Exon_num = paste(region_f_group[z+1,]$EXONRANK, '_', 0, sep="")
						break
					}
				}
			}
		}
		if ( !is.null(flag) ) { 
			Exon_max = max(region_f_group$EXONRANK) #// get total exon number of the transcript
			Trans_length = dataset[x,]$TXEND - dataset[x,]$TXSTART + 1; #//get transcript length
			tmp = cbind(t(Judge), t(flag$Prop), t(flag$EXONRANK), t(flag$exon), t(Exon_num), t(Exon_max), t(Trans_length), t(chr), t(strand), t(start), t(end));
			JE = rbind(JE, tmp, deparse.level=0); #// extend row of JE data.frame (including Judge, flag, Exon_num....)
		} else {
			stop("flag is NULL (no values assigned), and a bug needs to be fixed!");
		}
		if ( !is.null(region_f) ) { select_region_f = rbind(select_region_f, region_f) }			
	}
	#// build 'transcript' data.frame class, which combines info of dataset and JE
	transcript = cbind(as.data.frame(cbind(dataset$GENEID, dataset$TXNAME, dataset$TXSTART, dataset$TXEND)), JE); 
	names(transcript) = c("GENEID", "TXNAME", "TXSTART", "TXEND", "Judge", "Prop", "EXONRANK", "exon", "Exon_pos", "Exon_num", "Trans_length", "Chrom", "Strand", "GStart", "GEnd")
	transcript$Prop = as.numeric(transcript$Prop)	#// switch to the numeric type
	transcript$EXONRANK = as.numeric(transcript$EXONRANK) #// switch to the numeric type
	transcript$exon = as.character(transcript$exon) #// switch to the string type for exon name
	transcript$Exon_pos = as.character(transcript$Exon_pos) #// switch to the numeric type
	transcript$Exon_num = as.numeric(as.character(transcript$Exon_num)) #// switch to the numeric type
	transcript$Trans_length = as.numeric(as.character(transcript$Trans_length)) #// switch to the numeric type
	transcript$Strand = as.character(transcript$Strand) #// switch to the charater type
	transcript$GStart = as.numeric(as.character(transcript$GStart)) #// switch to the numeric type
	transcript$GEnd = as.numeric(as.character(transcript$GEnd)) #// switch to the numeric type
	#-# levels(transcript$Chrom) = sub("^chr", "", levels(transcript$Chrom), ignore.case=T) #// remove 'chr' 

	#// 'transcript' is a data.frame class used for evaluating breakpoint pos in each transcript, and 'select_region_f' is a data.frame class used for plotTracks
	assemble <- list(transcript=transcript, select_region=select_region_f)
	return(assemble)
}

